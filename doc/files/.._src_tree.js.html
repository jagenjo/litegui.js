<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/tree.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Area.html">Area</a></li>
                                <li><a href="../classes/ContextMenu.html">ContextMenu</a></li>
                                <li><a href="../classes/Dialog.html">Dialog</a></li>
                                <li><a href="../classes/Inspector.html">Inspector</a></li>
                                <li><a href="../classes/LineEditor.html">LineEditor</a></li>
                                <li><a href="../classes/List.html">List</a></li>
                                <li><a href="../classes/LiteGUI.html">LiteGUI</a></li>
                                <li><a href="../classes/SearchBox.html">SearchBox</a></li>
                                <li><a href="../classes/Slider.html">Slider</a></li>
                                <li><a href="../classes/Split.html">Split</a></li>
                                <li><a href="../classes/Tabs.html">Tabs</a></li>
                                <li><a href="../classes/Tree.html">Tree</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../src/tree.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//enclose in a scope
(function(){


/**
* To create interactive trees (useful for folders or hierarchies).&lt;br&gt;
* Options are:&lt;br&gt;
*	+ allow_multiselection: allow to select multiple elements using the shift key&lt;br&gt;
*	+ allow_rename: double click to rename items in the tree&lt;br&gt;
*	+ allow_drag: drag elements around&lt;br&gt;
*	+ height&lt;br&gt;
* Item data should be in the next format:&lt;br&gt;
* {&lt;br&gt;
*    id: unique_identifier,&lt;br&gt;
*    content: what to show in the HTML (if omited id will be shown)&lt;br&gt;
*	 children: []  array with another object with the same structure&lt;br&gt;
*	 className: class&lt;br&gt;
*    precontent: HTML inserted before the content&lt;br&gt;
*	 visible: boolean, to hide it&lt;br&gt;
*	 dataset: dataset for the element&lt;br&gt;
*	 onDragData: callback in case the user drags this item somewhere else&lt;br&gt;
* }&lt;br&gt;
* To catch events use tree.root.addEventListener(...)&lt;br&gt;
* item_selected : receive { item: node, data: node.data }&lt;br&gt;
* item_dblclicked&lt;br&gt;
* item_renamed&lt;br&gt;
* item_moved&lt;br&gt;
*
* @class Tree
* @constructor
*/

	/*********** LiteTree *****************************/
	function Tree( data, options, legacy )
	{
		if(legacy || (data &amp;&amp; data.constructor === String) )
		{
			var id = data;
			data = options;
			options = legacy || {};
			options.id = id;
			console.warn(&quot;LiteGUI.Tree legacy parameter, use data as first parameter instead of id.&quot;);
		}

		options = options || {};

		var root = document.createElement(&quot;div&quot;);
		this.root = root;
		if(options.id)
			root.id = options.id;

		root.className = &quot;litetree&quot;;
		this.tree = data;
		var that = this;
		options = options || {allow_rename: false, allow_drag: true, allow_multiselection: false};
		this.options = options;
		this.indent_offset = options.indent_offset || 0;

		if(options.height)
			this.root.style.height = typeof(options.height) == &quot;string&quot; ? options.height : Math.round(options.height) + &quot;px&quot;;

		//bg click
		root.addEventListener(&quot;click&quot;, function(e){
			if(e.srcElement != that.root)
				return;

			if(that.onBackgroundClicked)
				that.onBackgroundClicked(e,that);
		});

		//bg click right mouse
		root.addEventListener(&quot;contextmenu&quot;, function(e) { 
			if(e.button != 2) //right button
				return false;

			if(that.onContextMenu) 
				that.onContextMenu(e);
			e.preventDefault(); 
			return false;
		});


		var root_item = this.createAndInsert(data, options, null);
		if(!root_item)
			throw(&quot;Error in LiteGUI.Tree, createAndInsert returned null&quot;);
		root_item.className += &quot; root_item&quot;;
		//this.root.appendChild(root_item);
		this.root_item = root_item;
	}

	Tree.INDENT = 20;


	/**
	* update tree with new data (old data will be thrown away)
	* @method updateTree
	* @param {object} data
	*/
	Tree.prototype.updateTree = function(data)
	{
		this.root.innerHTML = &quot;&quot;;
		var root_item = this.createAndInsert( data, this.options, null);
		if(root_item)
		{
			root_item.className += &quot; root_item&quot;;
			//this.root.appendChild(root_item);
			this.root_item = root_item;
		}
		else
			this.root_item = null;
	}

	/**
	* update tree with new data (old data will be thrown away)
	* @method insertItem
	* @param {object} data
	* @param {string} parent_id
	* @param {number} position index in case you want to add it before the last position
	* @param {object} options
	* @return {DIVElement}
	*/
	Tree.prototype.insertItem = function( data, parent_id, position, options)
	{
		if(!parent_id)
		{
			var root = this.root.childNodes[0];
			if(root)
				parent_id = root.dataset[&quot;item_id&quot;];
		}

		var element = this.createAndInsert( data, options, parent_id, position );

		//update parent collapse button
		if(parent_id)
			this._updateListBox( this._findElement(parent_id) ); //no options here, this is the parent


		return element;
	}

	Tree.prototype.createAndInsert = function( data, options, parent_id, element_index )
	{
		//find parent
		var parent_element_index = -1;
		if(parent_id)
			parent_element_index = this._findElementIndex( parent_id );
		else if(parent_id === undefined)
			parent_element_index = 0; //root

		var parent = null;
		var child_level = 0;

		//find level
		if(parent_element_index != -1)
		{
			parent = this.root.childNodes[ parent_element_index ];
			child_level = parseInt( parent.dataset[&quot;level&quot;] ) + 1;
		}

		//create
		var element = this.createTreeItem( data, options, child_level );
		if(!element) //error creating element
			return;

		element.parent_id = parent_id;

		//check
		var existing_item = this.getItem( element.dataset[&quot;item_id&quot;] );
		if( existing_item )
			console.warn(&quot;There another item with the same ID in this tree&quot;);

		//insert
		if(parent_element_index == -1)
			this.root.appendChild( element );
		else
			this._insertInside( element, parent_element_index, element_index );

		//compute visibility according to parents
		if( parent &amp;&amp; !this._isNodeChildrenVisible( parent_id ) )
			element.classList.add(&quot;hidden&quot;);

		//children
		if(data.children)
		{
			for(var i = 0; i &lt; data.children.length; ++i)
			{
				this.createAndInsert( data.children[i], options, data.id );
			}
		}

		//update collapse button
		this._updateListBox( element, options );

		if(options &amp;&amp; options.selected)
			this.markAsSelected( element, true );

		return element;
	}

	//element to add, position of the parent node, position inside children, the depth level
	Tree.prototype._insertInside = function( element, parent_index, offset_index, level )
	{
		var parent = this.root.childNodes[ parent_index ];
		if(!parent)
			throw(&quot;No parent node found, index: &quot; + parent_index +&quot;, nodes: &quot; + this.root.childNodes.length );

		var parent_level = parseInt( parent.dataset[&quot;level&quot;] );
		var child_level = level !== undefined ? level : parent_level + 1;

		var indent = element.querySelector(&quot;.indentblock&quot;);
		if(indent)
			indent.style.paddingLeft = ((child_level + this.indent_offset) * Tree.INDENT ) + &quot;px&quot;; //inner padding
		
		element.dataset[&quot;level&quot;] = child_level;

		//under level nodes
		for( var j = parent_index+1; j &lt; this.root.childNodes.length; ++j )
		{
			var new_childNode = this.root.childNodes[j];
			if( !new_childNode.classList || !new_childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;
			var current_level = parseInt( new_childNode.dataset[&quot;level&quot;] );

			if( current_level == child_level &amp;&amp; offset_index)
			{
				offset_index--;
				continue;
			}

			//last position
			if( current_level &lt; child_level || (offset_index === 0 &amp;&amp; current_level === child_level) )
			{
				this.root.insertBefore( element, new_childNode );
				return;
			}
		}

		//ended
		this.root.appendChild( element );
	}


	Tree.prototype._isNodeChildrenVisible = function( id )
	{
		var node = this.getItem( id );
		if(!node)
			return false;
		if( node.classList.contains(&quot;hidden&quot;) )
			return false;

		//check listbox
		var listbox = node.querySelector(&quot;.listbox&quot;);
		if(!listbox)
			return true;
		if(listbox.getValue() == &quot;closed&quot;)
			return false;
		return true;
	}

	Tree.prototype._findElement = function( id )
	{
		if( !id || id.constructor !== String)
			throw(&quot;findElement param must be string with item id&quot;);
		for(var i = 0; i &lt; this.root.childNodes.length; ++i)
		{
			var childNode = this.root.childNodes[i];
			if( !childNode.classList || !childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;
			if( childNode.classList.contains(&quot;ltreeitem-&quot; + id) )
				return childNode;
		}

		return null;
	}

	Tree.prototype._findElementIndex = function( id )
	{
		for(var i = 0; i &lt; this.root.childNodes.length; ++i)
		{
			var childNode = this.root.childNodes[i];
			if( !childNode.classList || !childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;

			if(typeof(id) === &quot;string&quot;)
			{
				if(childNode.dataset[&quot;item_id&quot;] === id)
					return i;
			}
			else if( childNode === id )
				return i;
		}

		return -1;
	}

	Tree.prototype._findElementLastChildIndex = function( start_index )
	{
		if(start_index == -1)
			return -1;

		var level = parseInt( this.root.childNodes[ start_index ].dataset[&quot;level&quot;] );

		for(var i = start_index+1; i &lt; this.root.childNodes.length; ++i)
		{
			var childNode = this.root.childNodes[i];
			if( !childNode.classList || !childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;

			var current_level = parseInt( childNode.dataset[&quot;level&quot;] );
			if( current_level == level )
				return i;
		}

		return -1;
	}

	//returns child elements (you can control levels)
	Tree.prototype._findChildElements = function( id, only_direct )
	{
		var parent_index = this._findElementIndex( id );
		if(parent_index == -1)
			return;

		var parent = this.root.childNodes[ parent_index ];
		var parent_level = parseInt( parent.dataset[&quot;level&quot;] );

		var result = [];

		for(var i = parent_index + 1; i &lt; this.root.childNodes.length; ++i)
		{
			var childNode = this.root.childNodes[i];
			if( !childNode.classList || !childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;

			var current_level = parseInt( childNode.dataset[&quot;level&quot;] );
			if(only_direct &amp;&amp; current_level &gt; (parent_level + 1) )
				continue;
			if(current_level &lt;= parent_level)
				return result;

			result.push( childNode );
		}

		return result;
	}
	
	Tree.prototype.createTreeItem = function( data, options, level )
	{
		if(data === null || data === undefined)
		{
			console.error(&quot;Tree item cannot be null&quot;);
			return;
		}

		options = options || this.options;

		var root = document.createElement(&quot;li&quot;);
		root.className = &quot;ltreeitem&quot;;
		var that = this;

		//ids are not used because they could collide, classes instead
		if(data.id)
		{
			var safe_id = data.id.replace(/\s/g,&quot;_&quot;);
			root.className += &quot; ltreeitem-&quot; + safe_id;
			root.dataset[&quot;item_id&quot;] = data.id;
		}

		if(data.dataset)
			for(var i in data.dataset)
				root.dataset[i] = data.dataset[i];

		data.DOM = root; //double link
		root.data = data;

		if(level !== undefined)
		{
			root.dataset[&quot;level&quot;] = level;
			root.classList.add(&quot;ltree-level-&quot; + level);
		}

		var title_element = document.createElement(&quot;div&quot;);
		title_element.className = &quot;ltreeitemtitle&quot;;
		if(data.className)
			title_element.className += &quot; &quot; + data.className;

		title_element.innerHTML = &quot;&lt;span class=&#x27;precontent&#x27;&gt;&lt;/span&gt;&lt;span class=&#x27;indentblock&#x27;&gt;&lt;/span&gt;&lt;span class=&#x27;collapsebox&#x27;&gt;&lt;/span&gt;&lt;span class=&#x27;incontent&#x27;&gt;&lt;/span&gt;&lt;span class=&#x27;postcontent&#x27;&gt;&lt;/span&gt;&quot;;


		var content = data.content || data.id || &quot;&quot;;
		title_element.querySelector(&quot;.incontent&quot;).innerHTML = content;

		if(data.precontent)
			title_element.querySelector(&quot;.precontent&quot;).innerHTML = data.precontent;

		if(data.dataset)
			for(var i in data.dataset)
				root.dataset[i] = data.dataset[i];

		root.appendChild( title_element );
		root.title_element = title_element;

		if(data.visible === false)
			root.style.display = &quot;none&quot;;

		//var row = root.querySelector(&quot;.ltreeitemtitle .incontent&quot;);
		var row = root;
		row.addEventListener(&quot;click&quot;, onNodeSelected );
		row.addEventListener(&quot;dblclick&quot;,onNodeDblClicked );
		row.addEventListener(&quot;contextmenu&quot;, function(e) { 
			var item = this;
			e.preventDefault(); 
			e.stopPropagation();

			if(e.button != 2) //right button
				return;

			if(that.onItemContextMenu)
				return that.onItemContextMenu(e, { item: item, data: item.data} );

			return false;
		});

		function onNodeSelected(e)
		{
			e.preventDefault();
			e.stopPropagation();

			//var title = this.parentNode;
			//var item = title.parentNode;
			var node = this;
			var title = node.title_element;

			if(title._editing) 
				return;

			if(e.ctrlKey &amp;&amp; that.options.allow_multiselection)
			{
				//check if selected
				if( that.isNodeSelected( node ) )
				{
					node.classList.remove(&quot;selected&quot;);
					LiteGUI.trigger(that.root, &quot;item_remove_from_selection&quot;, { item: node, data: node.data} );
					return;
				}

				//mark as selected
				that.markAsSelected( node, true );
				LiteGUI.trigger(that.root, &quot;item_add_to_selection&quot;, { item: node, data: node.data} );
				var r = false;
				if(data.callback) 
					r = data.callback.call(that,node);

				if(!r &amp;&amp; that.onItemAddToSelection)
					that.onItemAddToSelection(node.data, node);
			}
			if(e.shiftKey &amp;&amp; that.options.allow_multiselection)
			{
				//select from current selection till here
				//current
				var last_item = that.getSelectedItem();
				if(!last_item)
					return;

				if(last_item === node)
					return;

				var nodeList = Array.prototype.slice.call( last_item.parentNode.children );
				var last_index = nodeList.indexOf( last_item );
				var current_index = nodeList.indexOf( node );

				var items = current_index &gt; last_index ? nodeList.slice( last_index, current_index ) : nodeList.slice( current_index, last_index );
				for( var i = 0; i &lt; items.length; ++i )
				{
					var item = items[i];
					//console.log(item);
					//mark as selected
					that.markAsSelected( item, true );
					LiteGUI.trigger( that.root, &quot;item_add_to_selection&quot;, { item: item, data: item.data } );
				}
			}
			else
			{
				//mark as selected
				that.markAsSelected( node );

				that._skip_scroll = true; //avoid scrolling while user clicks something
				LiteGUI.trigger(that.root, &quot;item_selected&quot;, { item: node, data: node.data} );
				var r = false;
				if(data.callback) 
					r = data.callback.call(that,node);

				if(!r &amp;&amp; that.onItemSelected)
					that.onItemSelected(node.data, node);
				that._skip_scroll = false;
			}
		}

		function onNodeDblClicked(e)
		{
			var node = this; //this.parentNode;
			var title = node.title_element.querySelector(&quot;.incontent&quot;);

			LiteGUI.trigger( that.root, &quot;item_dblclicked&quot;, node );

			if(!title._editing &amp;&amp; that.options.allow_rename)
			{
				title._editing = true;
				title._old_name = title.innerHTML;
				var that2 = title;
				title.innerHTML = &quot;&lt;input type=&#x27;text&#x27; value=&#x27;&quot; + title.innerHTML + &quot;&#x27; /&gt;&quot;;
				var input = title.querySelector(&quot;input&quot;);

				//loose focus when renaming
				$(input).blur(function(e) { 
					var new_name = e.target.value;
					setTimeout(function() { that2.innerHTML = new_name; },1); //bug fix, if I destroy input inside the event, it produce a NotFoundError
					//item.node_name = new_name;
					delete that2._editing;
					LiteGUI.trigger( that.root, &quot;item_renamed&quot;, { old_name: that2._old_name, new_name: new_name, item: node, data: node.data } );
					delete that2._old_name;
				});

				//finishes renaming
				input.addEventListener(&quot;keydown&quot;, function(e) {
					if(e.keyCode != 13)
						return;
					$(this).blur();
				});

				//set on focus
				$(input).focus();

				e.preventDefault();
			}
			
			e.preventDefault();
			e.stopPropagation();
		}

		//dragging element on tree
		var draggable_element = title_element;
		if(this.options.allow_drag)
		{
			draggable_element.draggable = true;

			//starts dragging this element
			draggable_element.addEventListener(&quot;dragstart&quot;, function(ev) {
				//this.removeEventListener(&quot;dragover&quot;, on_drag_over ); //avoid being drag on top of himself
				//ev.dataTransfer.setData(&quot;node-id&quot;, this.parentNode.id);
				ev.dataTransfer.setData(&quot;item_id&quot;, this.parentNode.dataset[&quot;item_id&quot;]);
				if(!data.onDragData)
					return;

				var drag_data =	data.onDragData();
				if(drag_data)
				{
					for(var i in drag_data)
						ev.dataTransfer.setData(i,drag_data[i]);
				}
			});
		}

		var count = 0;

		//something being dragged entered
		draggable_element.addEventListener(&quot;dragenter&quot;, function (ev)
		{
			ev.preventDefault();
			if(data.skipdrag)
				return false;
			
			if(count == 0)
				title_element.classList.add(&quot;dragover&quot;);
			count++;
		});

		draggable_element.addEventListener(&quot;dragleave&quot;, function (ev)
		{
			ev.preventDefault();
			//console.log(data.id);
			count--;
			if(count == 0)
				title_element.classList.remove(&quot;dragover&quot;);
			//if(ev.srcElement == this) return;
		});

		//test if allows to drag stuff on top?
		draggable_element.addEventListener(&quot;dragover&quot;, on_drag_over );
		function on_drag_over(ev)
		{
			ev.preventDefault();
		}

		draggable_element.addEventListener(&quot;drop&quot;, function (ev)
		{
			title_element.classList.remove(&quot;dragover&quot;);
			ev.preventDefault();
			if(data.skipdrag)
				return false;

			var item_id = ev.dataTransfer.getData(&quot;item_id&quot;);

			//var data = ev.dataTransfer.getData(&quot;Text&quot;);
			if(!item_id)
			{
				LiteGUI.trigger( that.root, &quot;drop_on_item&quot;, { item: this, event: ev });
				if( that.onDropItem )
					that.onDropItem( ev, this.parentNode.data );
				return;
			}

			//try
			{
				var parent_id = this.parentNode.dataset[&quot;item_id&quot;];

				if( !that.onMoveItem || (that.onMoveItem &amp;&amp; that.onMoveItem( that.getItem( item_id ), that.getItem( parent_id ) ) != false))
				{
					if( that.moveItem( item_id, parent_id ) )
						LiteGUI.trigger( that.root, &quot;item_moved&quot;, { item: that.getItem( item_id ), parent_item: that.getItem( parent_id ) } );
				}
			}
			/*
			catch (err)
			{
				console.error(&quot;Error: &quot; + err );
			}
			*/

			if( that.onDropItem )
				that.onDropItem( ev, this.parentNode.data );
		});

		return root;
	}


	/**
	* remove from the tree the items that do not have a name that matches the string
	* @method filterByName
	* @param {string} name
	*/
	Tree.prototype.filterByName = function(name)
	{
		for(var i = 0; i &lt; this.root.childNodes.length; ++i)
		{
			var childNode = this.root.childNodes[i]; //ltreeitem
			if( !childNode.classList || !childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;

			var content = childNode.querySelector(&quot;.incontent&quot;);
			if(!content)
				continue;

			var str = content.innerHTML.toLowerCase();

			if(!name || str.indexOf( name.toLowerCase() ) != -1)
			{
				if( childNode.data &amp;&amp; childNode.data.visible !== false )
					childNode.classList.remove(&quot;filtered&quot;);
				var indent = childNode.querySelector(&quot;.indentblock&quot;);
				if(indent)
				{
					if(name)
						indent.style.paddingLeft = 0;
					else
						indent.style.paddingLeft = paddingLeft = ( (parseInt(childNode.dataset[&quot;level&quot;]) + this.indent_offset) * Tree.INDENT) + &quot;px&quot;;
				}
			}
			else
			{
				childNode.classList.add(&quot;filtered&quot;);
			}
		}
	}	

	/**
	* remove from the tree the items that do not have a name that matches the string
	* @method filterByName
	* @param {string} name
	*/
	Tree.prototype.filterByRule = function( callback_to_filter, param )
	{
		if(!callback_to_filter)
			throw(&quot;filterByRule requires a callback&quot;);
		for(var i = 0; i &lt; this.root.childNodes.length; ++i)
		{
			var childNode = this.root.childNodes[i]; //ltreeitem
			if( !childNode.classList || !childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;

			var content = childNode.querySelector(&quot;.incontent&quot;);
			if(!content)
				continue;

			if( callback_to_filter( childNode.data, content, param ) )
			{
				if( childNode.data &amp;&amp; childNode.data.visible !== false )
					childNode.classList.remove(&quot;filtered&quot;);
				var indent = childNode.querySelector(&quot;.indentblock&quot;);
				if(indent)
				{
					if(name)
						indent.style.paddingLeft = 0;
					else
						indent.style.paddingLeft = paddingLeft = ( (parseInt(childNode.dataset[&quot;level&quot;]) + this.indent_offset) * LiteGUI.Tree.INDENT) + &quot;px&quot;;
				}
			}
			else
			{
				childNode.classList.add(&quot;filtered&quot;);
			}
		}
	}	


	/**
	* get the item with that id, returns the HTML element
	* @method getItem
	* @param {string} id
	* @return {Object}
	*/
	Tree.prototype.getItem = function( id )
	{
		if(!id)
			return null;

		if( id.classList ) //if it is already a node
			return id;

		for(var i = 0; i &lt; this.root.childNodes.length; ++i)
		{
			var childNode = this.root.childNodes[i];
			if( !childNode.classList || !childNode.classList.contains(&quot;ltreeitem&quot;) )
				continue;

			if(childNode.dataset[&quot;item_id&quot;] === id)
				return childNode;
		}

		return null;

		/*
		var safe_id = id.replace(/\s/g,&quot;_&quot;);
		var node = this.root.querySelector(&quot;.ltreeitem-&quot;+safe_id);
		if(!node) 
			return null;
		if( !node.classList.contains(&quot;ltreeitem&quot;) )
			throw(&quot;this node is not a tree item&quot;);
		return node;
		*/
	}

	/**
	* in case an item is collapsed, it expands it to show children
	* @method expandItem
	* @param {string} id
	*/
	Tree.prototype.expandItem = function(id)
	{
		var item = this.getItem(id);
		if(!item)
			return;

		if(!item.listbox)
			return;

		listbox.setValue(true); //this propagates changes
	}

	/**
	* in case an item is expanded, it collapses it to hide children
	* @method collapseItem
	* @param {string} id
	*/
	Tree.prototype.collapseItem = function(id)
	{
		var item = this.getItem(id);
		if(!item)
			return;

		if(!item.listbox)
			return;

		listbox.setValue(false);  //this propagates changes
	}


	/**
	* Tells you if the item its out of the view due to the scrolling
	* @method isInsideArea
	* @param {string} id
	*/
	Tree.prototype.isInsideArea = function( id )
	{
		var item = id.constructor === String ? this.getItem(id) : id;
		if(!item)
			return false;

		var rects = this.root.getClientRects();
		if(!rects.length)
			return false;
		var r = rects[0];
		var h = r.height;
		var y = item.offsetTop;

		if( this.root.scrollTop &lt; y &amp;&amp; y &lt; (this.root.scrollTop + h) )
			return true;
		return false;
	}

	/**
	* Scrolls to center this item
	* @method scrollToItem
	* @param {string} id
	*/
	Tree.prototype.scrollToItem = function(id)
	{
		var item = id.constructor === String ? this.getItem(id) : id;
		if(!item)
			return;

		var rects = this.root.getClientRects();
		if(!rects.length)
			return false;
		var r = rects[0];
		var h = r.height;
		var x = ( parseInt( item.dataset[&quot;level&quot;] ) + this.indent_offset) * Tree.INDENT + 50;

		this.root.scrollTop = item.offsetTop - (h * 0.5)|0;
		if( r.width * 0.75 &lt; x )
			this.root.scrollLeft = x;
		else
			this.root.scrollLeft = 0;
	}

	/**
	* mark item as selected
	* @method setSelectedItem
	* @param {string} id
	*/
	Tree.prototype.setSelectedItem = function( id, scroll, send_event )
	{
		if(!id)
		{
			//clear selection
			this.unmarkAllAsSelected();
			return;
		}

		var node = this.getItem(id);
		if(!node) //not found
			return null;

		//already selected
		if( node.classList.contains(&quot;selected&quot;) ) 
			return;

		this.markAsSelected(node);
		if( scroll &amp;&amp; !this._skip_scroll )
			this.scrollToItem(node);

		if(send_event)
			LiteGUI.trigger( node, &quot;click&quot; );

		return node;
	}

	/**
	* adds item to selection (multiple selection)
	* @method addItemToSelection
	* @param {string} id
	*/
	Tree.prototype.addItemToSelection = function( id )
	{
		if(!id)
			return;

		var node = this.getItem(id);
		if(!node) //not found
			return null;

		this.markAsSelected(node, true);
		return node;
	}

	/**
	* remove item from selection (multiple selection)
	* @method removeItemFromSelection
	* @param {string} id
	*/
	Tree.prototype.removeItemFromSelection = function( id )
	{
		if(!id)
			return;
		var node = this.getItem(id);
		if(!node) //not found
			return null;
		node.classList.remove(&quot;selected&quot;);
	}

	/**
	* returns the first selected item (its HTML element)
	* @method getSelectedItem
	* @return {HTML}
	*/
	Tree.prototype.getSelectedItem = function()
	{
		return this.root.querySelector(&quot;.ltreeitem.selected&quot;);
	}

	/**
	* returns an array with the selected items (its HTML elements)
	* @method getSelectedItems
	* @return {HTML}
	*/
	Tree.prototype.getSelectedItems = function()
	{
		return this.root.querySelectorAll(&quot;.ltreeitem.selected&quot;);
	}

	/**
	* returns if an item is selected
	* @method isItemSelected
	* @param {string} id
	* @return {bool}
	*/
	Tree.prototype.isItemSelected = function(id)
	{
		var node = this.getItem( id );
		if(!node)
			return false;
		return this.isNodeSelected(node);
	}

	/**
	* returns the children of an item
	* @method getChildren
	* @param {string} id could be string or node directly
	* @param {bool} [only_direct=false] to get only direct children
	* @return {Array}
	*/
	Tree.prototype.getChildren = function(id, only_direct )
	{
		if( id &amp;&amp; id.constructor !== String &amp;&amp; id.dataset )
			id = id.dataset[&quot;item_id&quot;];
		return this._findChildElements( id, only_direct );
	}

	/**
	* returns the parent of a item
	* @method getParent
	* @param {string} id
	* @return {HTML}
	*/
	Tree.prototype.getParent = function(id_or_node)
	{
		var element = this.getItem( id_or_node );
		if(element)
			return this.getItem( element.parent_id );
		return null;
	}

	/**
	* returns an array with all the ancestors
	* @method getAncestors
	* @param {string} id
	* @return {Array}
	*/
	Tree.prototype.getAncestors = function( id_or_node, result )
	{
		result = result || [];
		var element = this.getItem( id_or_node );
		if(element)
		{
			result.push( element );
			return this.getAncestors( element.parent_id, result );
		}
		return result;
	}

	/**
	* returns an array with all the ancestors
	* @method getAncestors
	* @param {string} id
	* @return {Array}
	*/
	Tree.prototype.isAncestor = function( child, node )
	{
		var element = this.getItem( child );
		if(!element)
			return false;
		var dest = this.getItem( node );
		var parent = this.getItem( element.parent_id );
		if(!parent)
			return false;
		if(parent == dest)
			return true;
		return this.isAncestor( parent, node );
	}

	/**
	* move item with id to be child of parent_id
	* @method moveItem
	* @param {string} id
	* @param {string} parent_id
	* @return {bool}
	*/
	Tree.prototype.moveItem = function( id, parent_id )
	{
		if(id === parent_id)
			return false;

		var node = this.getItem( id );
		var parent = this.getItem( parent_id );

		if( this.isAncestor( parent, node ) )
			return false;

		var parent_index = this._findElementIndex( parent );
		var parent_level = parseInt( parent.dataset[&quot;level&quot;] );
		var old_parent = this.getParent( node );
		if(!old_parent)
		{
			console.error(&quot;node parent not found by id, maybe id has changed&quot;);
			return false;
		}
		var old_parent_level = parseInt( old_parent.dataset[&quot;level&quot;] );
		var level_offset = parent_level - old_parent_level;

		if(!parent || !node)
			return false;

		if(parent == old_parent)
			return false;

		//replace parent info
		node.parent_id = parent_id;

		//get all children and subchildren and reinsert them in the new level
		var children = this.getChildren( node );
		if(children)
		{
			children.unshift( node ); //add the node at the beginning

			//remove all children
			for(var i = 0; i &lt; children.length; i++)
				children[i].parentNode.removeChild( children[i] );

			//update levels
			for(var i = 0; i &lt; children.length; i++)
			{
				var child = children[i];
				var new_level = parseInt(child.dataset[&quot;level&quot;]) + level_offset;
				child.dataset[&quot;level&quot;] = new_level;
			}

			//reinsert
			parent_index = this._findElementIndex( parent ); //update parent index
			var last_index = this._findElementLastChildIndex( parent_index );
			if(last_index == -1)
				last_index = 0;
			for(var i = 0; i &lt; children.length; i++)
			{
				var child = children[i];
				this._insertInside( child, parent_index, last_index + i - 1, parseInt( child.dataset[&quot;level&quot;] ) );
			}
		}
		
		//update collapse button
		this._updateListBox( parent );
		if(old_parent)
			this._updateListBox( old_parent );

		return true;
	}

	/**
	* remove item with given id
	* @method removeItem
	* @param {string} id
	* @return {bool}
	*/
	Tree.prototype.removeItem = function( id_or_node, remove_children )
	{
		var node = id_or_node;
		if(typeof(id_or_node) == &quot;string&quot;)
			node = this.getItem( id_or_node );
		if(!node)
			return false;

		//get parent
		var parent = this.getParent( node );

		//get all descendants
		var child_nodes = null;
		if(remove_children)
			child_nodes = this.getChildren( node );

		//remove html element
		this.root.removeChild( node );

		//remove all children
		if( child_nodes )
		{
			for( var i = 0; i &lt; child_nodes.length; i++ )
				this.root.removeChild( child_nodes[i] );
		}

		//update parent collapse button
		if(parent)
			this._updateListBox( parent );
		return true;
	}

	/**
	* update a given item with new data
	* @method updateItem
	* @param {string} id
	* @param {object} data
	*/
	Tree.prototype.updateItem = function(id, data)
	{
		var node = this.getItem(id);
		if(!node)
			return false;

		node.data = data;
		if(data.id)
			node.id = data.id; //this updateItemId ?
		if(data.content)
		{
			//node.title_element.innerHTML = &quot;&lt;span class=&#x27;precontent&#x27;&gt;&lt;/span&gt;&lt;span class=&#x27;incontent&#x27;&gt;&quot; +  + &quot;&lt;/span&gt;&lt;span class=&#x27;postcontent&#x27;&gt;&lt;/span&gt;&quot;;
			var incontent = node.title_element.querySelector(&quot;.incontent&quot;);
			incontent.innerHTML = data.content;
		}

		return true;
	}

	/**
	* update a given item id and the link with its children
	* @method updateItemId
	* @param {string} old_id
	* @param {string} new_id
	*/
	Tree.prototype.updateItemId = function(old_id, new_id)
	{
		var node = this.getItem(old_id);
		if(!node)
			return false;

		var children = this.getChildren( old_id, true );
		node.id = new_id;

		for(var i = 0; i &lt; children.length; ++i)
		{
			var child = children[i];
			child.parent_id = new_id;
		}

		return true;
	}


	/**
	* clears all the items
	* @method clear
	* @param {bool} keep_root if you want to keep the root item
	*/
	Tree.prototype.clear = function(keep_root)
	{
		if(!keep_root)
		{
			this.root.innerHTML = &quot;&quot;;
			return;
		}

		var items = this.root.querySelectorAll(&quot;.ltreeitem&quot;);
		for(var i = 1; i &lt; items.length; i++)
		{
			var item = items[i];
			this.root.removeChild( item );
		}
	}


	Tree.prototype.getNodeByIndex = function(index)
	{
		var items = this.root.querySelectorAll(&quot;.ltreeitem&quot;);
		return items[index];
	}

	//private ********************************

	Tree.prototype.unmarkAllAsSelected = function()
	{
		this.root.classList.remove(&quot;selected&quot;);
		var selected_array = this.root.querySelectorAll(&quot;.ltreeitem.selected&quot;);
		if(selected_array)
		{
			for(var i = 0; i &lt; selected_array.length; i++)
				selected_array[i].classList.remove(&quot;selected&quot;);
		}
		var semiselected = this.root.querySelectorAll(&quot;.ltreeitem.semiselected&quot;);
		for(var i = 0; i &lt; semiselected.length; i++)
			semiselected[i].classList.remove(&quot;semiselected&quot;);
	}

	Tree.prototype.isNodeSelected = function( node )
	{
		//already selected
		if( node.classList.contains(&quot;selected&quot;) ) 
			return true;
		return false;
	}

	Tree.prototype.markAsSelected = function( node, add_to_existing_selection )
	{
		//already selected
		if( node.classList.contains(&quot;selected&quot;) ) 
			return;

		//clear old selection
		if(!add_to_existing_selection)
			this.unmarkAllAsSelected();

		//mark as selected (it was node.title_element?)
		node.classList.add(&quot;selected&quot;);

		//go up and semiselect
		var parent = this.getParent( node );
		while(parent)
		{
			parent.classList.add(&quot;semiselected&quot;);
			parent = this.getParent( parent );
		}
		/*
		var parent = node.parentNode.parentNode; //two elements per level
		while(parent &amp;&amp; parent.classList.contains(&quot;ltreeitem&quot;))
		{
			parent.title_element.classList.add(&quot;semiselected&quot;);
			parent = parent.parentNode.parentNode;
		}
		*/
	}

	//updates the widget to collapse
	Tree.prototype._updateListBox = function( node, options )
	{
		if(!node)
			return;

		var that = this;

		if(!node.listbox)
		{
			var pre = node.title_element.querySelector(&quot;.collapsebox&quot;);
			var box = LiteGUI.createLitebox(true, function(e) { 
				that.onClickBox(e, node);
				LiteGUI.trigger( that.root, &quot;item_collapse_change&quot;, { item: node, data: box.getValue() } );
			});
			box.stopPropagation = true;
			box.setEmpty(true);
			pre.appendChild(box);
			node.listbox = box;
		}

		if(options &amp;&amp; options.collapsed)
			node.listbox.collapse();

		var child_elements = this.getChildren( node.dataset[&quot;item_id&quot;] );
		if(!child_elements)
			return; //null

		if(child_elements.length)
			node.listbox.setEmpty(false);
		else
			node.listbox.setEmpty(true);
	}

	Tree.prototype.onClickBox = function(e, node)
	{
		var children = this.getChildren( node );

		if(!children)
			return;

		//update children visibility
		for(var i = 0; i &lt; children.length; ++i)
		{
			var child = children[i];
			
			var child_parent = this.getParent( child );
			var visible = true;
			if( child_parent )
				visible = this._isNodeChildrenVisible(child_parent);
			if(visible)
				child.classList.remove(&quot;hidden&quot;);
			else
				child.classList.add(&quot;hidden&quot;);
		}
	}

	LiteGUI.Tree = Tree;
})();
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
